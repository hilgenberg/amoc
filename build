#!/usr/bin/env python
import os
import sys
import fnmatch
import shutil

##############################################################################
# configuration
##############################################################################

# config
target  = 'amoc'
libs    = ('z m db ncurses curl tag id3tag pthread faad avcodec avutil avformat ' +
           'speex modplug ogg vorbis vorbisfile mad popt sndfile FLAC ' +
           'wavpack asound jack sndio magic mpcdec resample samplerate timidity')
pch     = "config.h" # pre-compiled header path or None

# name => [additional cc_flags, additional linker_flags]
variants = {
		"debug":   ['-Og -DDEBUG -D_DEBUG -g', ''],
		"release": ['-O3 -s -DNDEBUG',         '-s -zrelro -znow'],
}

cflags = """-DUSE_PTHREADS
  -Wall -Wextra
  -Wno-sign-compare
  -Wno-deprecated-declarations
  -Wno-parentheses
  -Wno-misleading-indentation
  -Wno-variadic-macros
  -Wno-unused-parameter
  -Wno-unknown-pragmas
  -Wno-implicit-fallthrough
  -Wno-missing-field-initializers"""
ccflags = "-std=c++17 -fstrict-enums -Wno-reorder"
lflags  = ""

##############################################################################
# handle cleaning
##############################################################################

def usage():
	sys.exit(f"""Usage:
	build clean: delete all build products
	build <variant>: switch to variant and build it, variants being:
		{[v for v in variants]}
	build: build current variant (debug is default variant)

This will create build_variant directories and symlink the target executable
and build.ninja from the active variant into the base directory.

The build.ninja files must be regenerated via "build clean" after adding,
deleting, renaming or moving files around.""")

if len(sys.argv) == 2 and sys.argv[1] == "clean":
	if os.path.islink("build.ninja"): os.remove("build.ninja")
	if os.path.islink(target): os.remove(target)
	for variant in variants:
		d = "build_" + variant
		if os.path.exists(d): shutil.rmtree(d)
	sys.exit(0)

##############################################################################
# write build.ninja files for all build variants
##############################################################################

# add $ chars where needed
lflags += " " + ' '.join(['-l'+s for s in libs.split()])
cflags  =  cflags.replace("\n", " $\n").replace("\t", " ").strip()
lflags  =  lflags.replace("\n", " $\n").replace("\t", " ").strip()
ccflags = ccflags.replace("\n", " $\n").replace("\t", " ").strip()

del libs # done with that

# create/update symlinks for current build variant
if len(sys.argv) == 2 and sys.argv[1] in variants:
	d = 'build_' + sys.argv[1]
	if os.path.islink("build.ninja"): os.remove("build.ninja")
	if os.path.islink(target): os.remove(target)
	if not os.path.exists("build.ninja"):
		os.symlink(d + "/build.ninja", "build.ninja")
	if not os.path.exists(target):
		os.symlink(d + "/"+target, target)
elif len(sys.argv) != 1:
	usage()
elif not os.path.lexists("build.ninja") and not os.path.lexists(target):
	os.symlink("build_debug/build.ninja", "build.ninja")
	os.symlink("build_debug/"+target, target)

# write the build.ninja files
for variant,flags in variants.items():
	base = "build_" + variant
	file = os.path.join(base, "build.ninja")
	if os.path.lexists(file): continue
	if not os.path.exists(base): os.mkdir(base)
	with open(file, "w") as f:
		stdout = sys.stdout
		sys.stdout = f
		pch_flags = "" if not pch else f" -I{base} -include {pch}.pch.h -Winvalid-pch"
		print(f"""#auto-generated by ./build, delete to regenerate.

builddir = {base}

cflags = {cflags} {flags[0]}

ccflags = $cflags {ccflags}

lflags = {lflags} {flags[1]}

rule cc
  command = g++ -MD -MF $out.dep $ccflags{pch_flags} -c $in -o $out
  depfile = $out.dep
  deps = gcc
  description = \033[32mCC\033[m $in

rule c
  command = gcc -MD -MF $out.dep $cflags -c $in -o $out
  depfile = $out.dep
  deps = gcc
  description = \033[32mC \033[m $in

rule pch
  command = g++ -MD -MF $out.dep $ccflags -x c++-header -c $in -o $out
  depfile = $out.dep
  deps = gcc
  description = \033[32mHH\033[m $in

rule link
  command = g++ $lflags $in -o $out
  description = \033[32mLL\033[m $out

""")

		PCH_DEP = ""
		if pch is not None:
			print(f"build {base}/{pch}.pch.h.gch: pch {pch}")
			PCH_DEP = f" || {base}/{pch}.pch.h.gch"

		# find all files to compile
		obj = []
		glsl = []
		for R,D,F in os.walk('.'):
			if "stuff" in D: D.remove("stuff")
			if ".git" in D: D.remove(".git")
			for v in variants:
				if f"build_{v}" in D: D.remove(f"build_{v}")

			for f in fnmatch.filter(F, '*.cc'):
				print(f"build {base}/{f}.o: cc {os.path.join(R, f)}{PCH_DEP}")
				obj.append(f"{base}/{f}.o")

		print(f"build {base}/{target}: link {' '.join(obj)}")

		sys.stdout = stdout


##############################################################################
# build the active variant
##############################################################################

os.system("TERM=dumb ninja")

